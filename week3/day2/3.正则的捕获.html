<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
    /*
        匹配 test
        捕获 exec 从字符串中获取 满足 正则的部分 字符
    */
   //exec 捕获的结果 第一项是大正则捕获到的内容 第二项及以后是小分组捕获到的内容
   //第二项就是第一个小分组；第三项就是第二个小分组
   //若字符串中没有任何符合正则的字符，则获取到的结果就是null

   var reg = /([a-z]+)(\d+)/;
   var str = '珠峰2019zf2020'
   var res = reg.exec(str)
   console.log(res);
   //正则的贪婪行  一次性会把所有满足正则的字符都捕获到\
   var reg = /\d+/;
   var str = '珠峰2019zf2020'
   var res = reg.exec(str)
   console.log(res);//2019
   //解决正则的贪婪行 用?
   var reg = /\d+?/;
   var str = '珠峰2019zf2020'
   var res = reg.exec(str)
   console.log(res);//2
   //捕获的懒惰性 只捕获一次 不再捕获其他符合条件的了
   //解决  通过添加全局修饰符 g 解决；加上g之后，每一个捕获是都会更新lastindex属性，lastindex控制的是下次匹配开始的索引
   //test 和exec方法 都会更新lastindex属性
   
   var reg = /\d+/g;
   var str = '珠峰2019zf2020'
  
   console.log(reg.exec(str));
   console.log(reg.exec(str));
   console.log(reg.exec(str));
   console.log(reg.exec(str));
   console.log(reg.exec(str));
   
</script>