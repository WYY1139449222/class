<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
    //获取字数做多的字符
    var str = 'sejdbkuesgdisgdkuecguyciewdgxuwdytwefdywgjwgywef'
  var reg = /(\d+)\1/   //  \1代表第一个小分组匹配的内容  \2代表第二个小分组匹配的内容
//   var str = '123123';
//   console.log(reg.exec(str));

  function getMax(str){
    str = str.split('').sort().join('');
    let k = '',n = 0;
    str.replace(/(\w)\1*/g,function(a,b){   
       if(a.length>n){
           n=a.length;
           k = b
       }
       return {
           k,n
       }
        
    })

    //   str = str.split('').sort().join('');
    //   console.log(str);
    //   var arr = str.match(/(\w)\1*/g)
    //   console.log(arr);
    //   arr.sort((a,b)=>b.length-a.length)
    //   return {
    //       key:arr[0][0],
    //         num:arr[0].length
    //   }
  }

  console.log(getMax(str));

    // function getMax(str){
    //     let obj = {};
    //     for (let i = 0; i < str.length; i++) {
    //        //把字符串中的没一项都当做熟悉名存起来
    //        //存之前看一下对象中是否有该属性，没有加，有的话+1
    //        if(obj.hasOwnProperty(str[i])){
    //             obj[str[i]]++
    //        }else{
    //            obj[str[i]]=1
    //        }

    //     }
    //     var val = Object.values(obj)
    //     var key = Object.keys(obj)
    //     console.log(val);
    //     console.log(key);
        
    //     var m = Math.max(...val)
    //     var n = key[val.indexOf(m)]
    // //     let k ='',num=0;
    // //    for (const key in obj) {
    // //        if(obj[key>num]){
    // //            k=key;
    // //            num=obj[key]
    // //        }
    // //    }
    //     return {
    //        n,m
    //     }
    // }
    // console.log(getMax(str));
    
</script>