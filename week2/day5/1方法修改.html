<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>

<script>

    /*
         类     实例
        人类   奥巴马
        Array   []
        Function f
        Object {}   基类

        原型链  属性的查找机制  自己没有 默认通过__proto__向所属类的原型上查找，        若没有的话，可以一直查找到基类的原型上  
        作用域链 变量的查找机制

        每一个函数(类)都有一个自带的prototype 指向自己的原型对象
        每一个对象（实例） 都有一个自带的__proto__指向所属类的原型对象
        每一个默认的原型对象都有一个constructor 指向自己的构造函数本身

        自定义类   var p1 = new Person(); 自定义类只能通过new创建
        内置类创建 var arr=[]//var arr = new Array([])
    */ 
    // function Person(){
    //     this.name = 123;
    // }
    // Person.prototype.eat = function(){

    // }
    // var p1 = new Person();
    // //p1就是Person的一个实例
    // class Man{
    //     constructor(){
    //         this.name= 123;
    //     }
    //     eat(){
    //         //保证 这里的this都是当前类的实例
    //         //class声明的类 原型上共有属性只能是函数
    //     }
    // }
    // var m1 = new Man();
    // //m1就是Man的的一个实例


    // Array.prototype.pop = function(n=1){
    //     //n代表了要删除的末尾的项数 把删除的项组成一个新的数组返回
    //     if(n>this.length)n=this.length;
    //     let arr = []
    //     for (let i =this.length-n; i < this.length; i++) {
    //        arr[arr.length] = this[i]
    //     }
    //     this.length-=n;
    //     return arr;
    // }

   
    // console.log(ary.pop());
    // Array.prototype = {};//原型重构 不起作用 内置类的原型是不能重新赋值的 
    //自定义类的原型重构时 需要注意 constructor 的指向
    //max 数组中的最大值   average 求数组的平均值
    let ary = [1,2,3,4,5,6,7,8]
    Array.prototype.max = function(){
        return Math.max(...this)
        return this.sort((a,b)=>b-a)[0]
        return Math.max.apply(Math,this)
    }
    Array.prototype.average = function(){
       return this.reduce((a,b)=>a+b)/(this.length);
    }
console.log(ary.max());
console.log(ary.average());


</script>